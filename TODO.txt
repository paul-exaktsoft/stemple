TODO:
Get rid of shared_ptr in InStream - InStream => BaseStream, + derived classes to hold ifstream, istringstream (including single-char putback)
A lighter-weight putback solution for single characters
Enclosing position reported should be start of directive, not end
Whitespace putback needs start position (not important because we won't report errors in whitespace!)
$(not) and $(or) should be n-ary, not just binary
C-only interface
$(include) path should be relative to current file path
Best practice for reporting errors? (not fatal exceptions)
Report errors with file/source/line/column location
Best practice for versioning executable
Memory leak detection for unit tests
Variable substitution:
$(<name>:<mods>)						<mods> modify expansion, like csh
	:w trim whitespace from result after expansion (:f/:b trim front/back) or $(trim $(<name>))?
	:n [input] do not trim whitespace from arguments before expansion
	:l/:u change case or $(lower $(<name>))
	:c capitalize or $(capitalize $(<name>))
	:i [input] ignore case (for $(equals), etc.)
	:h returns the directory of a path (aka "head")
	:t returns the filename of a path (aka "tail")
	:r returns the directory and filename without the last extension (aka "root")
	:e returns the extension of the path (aka "end")
	:s/match/replacement/ substitute or $(replace $(<name>),<match>,<replacement>)
	:offset[:length] substring or $(substr $(<name>),offset[,length])
Allow mods to be chained, eg :h:h:e
$(exec <shell_command>)
$((<expr>))								Substitute result of evaluated arithmetic expression
$(if <expr>)							<expr> is arithmetic or logical expression (or use $(if $((x > 0))) maybe?)
$(length <name>)						Length of macro body? Or of text argument? Need arithmetic expression 1st
$(*[:<offset>[:<length>]])				All arguments (or a subset) [What separator? ' ' or ','? Or user-defined?]
$(for NAME, <init>, <test>, <update>)	Uses arithmetic expressions
$(foreach NAME, <text>[, <text>]*)...$(end)
$(// <any_freeform_comment_text>)		Or $(rem ...)?
$(set <chars>)							Set special chars
Asserts
CMakeLists.txt
Test building with Xcode and Linux Makefile
Define IFS for array separator
Array indexing
$() macro to look up values in Excel (or Google Sheets) (or a SQL db) (or MongoDB)
$() macro to insert a numbered line from a file (or a range of lines, with column range(s) too)
Verbosity - report files opening/closing - file/macro/line/word/char counts - time? - expansion factor
Doxygen comments

DONE:
$(<name>)								<name> is just text, so can contain $() expansions too. <name> cannot contain spaces or special chars
$$(...									Literal (escaped) "$("
$(<name> <text>[, <text>]...)			<text> can contain $() expansions too, text can contain spaces. (Leading spaces? After single separating <space> or <tab>?)
$(1), $(2), etc...						Arguments to current macro
Google Test/Mock unit tests
[<wspace>]$(...)[<wspace>]<nl>			Line is ignored (allows $() on a line by itself without adding a blank line to the output)
$(<name>=<text>)						<text> can containing leading whitespace. Embedded $()s are expanded recursively when body is expanded
Use variables for special chars
[<wspace>]$(...)[<wspace>]$<nl>			Line is not ignored
Make special characters configurable
$(<name>:=<text>)						Embedded $() are expanded once at definition time (like Make's 'simply expanded' flavor of variable)
$(<name>+=<text>)						Append
$(<name>:+=<text>)						Append, 'simply expanded'
$(if <expr_text>, <true_text>[, <false_text>])
$(if <text>)						"", "0", or "false" (case insensitive) are false - everything else is true
$(elseif <text>)
$(else)
$(endif)
Define (customizable) distinct escape character, so allow:
	\$() [escaped $]
	$(...)\<newline> [non-skipped blank line]
	$(xxx a\,b) [single arg contains embedded comma]
	$(yyy a,\ b ) [non-trimmed leading & trailing space in arg]
	$(zzz abc\), def) [first arg contains embedded closing paren]
Trim arguments by default - use ,$<whitespace><text> escape after argsep (need modifier to preserve whitespace for all args. Eg, :n)
$(env <var>)
$(include <pathname>[, <text>]*)
$(equal <text>, <pattern>)				"true" else "false"
$(notequal <text>, <pattern>)
$(match <text>, <regex>)
$(and <text>, <text>)
$(or <text>, <text>)
$(not <text>, <text>)
$(defined <name>)						"true" else "false"
Implement stemple command:
	-D|-dname[=text]
	-D|-d|--define name[=text]		Define macro
	-h|--help				
	-v|--verbose			
	-V|--version			
	-c|--chars <specials>
	input output					Files or stdin/stdout (name can be -)
Cull eof streams just before read - so top stream (and position) stays active all the time c is in play
Get rid of std::shared_ptr for input and output streams
Putback store with position from original stream for each character
